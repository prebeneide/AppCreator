# Development Rules & Guidelines

## Core Principle: Mini-Steps Always

### Rule 1: Atomic Changes
- **One logical change per commit**
- Never combine unrelated features
- Test after each step before proceeding
- If a change breaks something, it's easier to identify and fix

### Rule 2: Maximum Step Size
- **One file at a time** when possible
- **One component** per implementation
- **One function** per logical operation
- If a change touches multiple files, ensure each file change is atomic

### Rule 3: Test and Run App After Every Step
- **Mandatory**: After every code change, run the app and verify it works
- Start the app (`pnpm dev` or equivalent) and check for runtime errors
- Verify the specific feature/change works as expected
- Check console for errors, warnings, or crashes
- Fix any errors immediately before proceeding to next step
- Don't accumulate changes and test at the end - test after each atomic change
- If app doesn't start or crashes: stop, fix, then continue

**Testing checklist after each step:**
1. App starts without errors
2. No console errors or warnings
3. The changed feature works as intended
4. No regressions in existing features
5. Lint/format checks pass

**Only proceed to next step when all checks pass.**

### Rule 4: Clear Commit Messages
- Use conventional commits format
- Be specific about what changed
- Example: `feat(chat): add message streaming support`
- Not: `update stuff`

---

## Code Style Rules

### Rule 5: Professional Code Comments
- Write comments as if you (the developer) wrote them
- Natural, conversational tone
- Explain "why" not "what"
- No "AI-generated" markers or excessive explanations

**Good:**
```typescript
// Debounce preview updates to avoid expensive rebuilds on every keystroke
const debouncedUpdate = useDebounce(updatePreview, 500);
```

**Bad:**
```typescript
// AI: This function debounces the preview update to optimize performance
// This was generated by AI to handle user input efficiently
// The debounce delay is set to 500ms which is optimal for user experience
```

### Rule 5.1: Never Write Like AI in Public Files
- **Critical**: All public-facing files (README, docs, comments) must sound human-written
- No emojis in technical documentation
- No excessive explanations or marketing language
- Keep it minimal, direct, and natural
- Write in Norwegian for Norwegian projects
- Avoid phrases like "This project features...", "With this tool you can...", etc.
- Prefer: "Mobilapp-bygger med AI-støtte" over "A powerful AI-powered mobile app builder that enables users to..."

**Public files include:**
- README.md
- Any documentation in root or public folders
- Code comments (covered in Rule 5)
- User-facing error messages

**Exception:** `.internal/` folder can contain detailed technical documentation

### Rule 6: No Hardcoded Text
- All UI text must use i18n keys
- Agent rule: Never generate hardcoded strings
- Validation: Lint rule to catch hardcoded strings

### Rule 7: No Hardcoded Dates
- All date/time operations use central Date util
- Agent rule: Never inline date formatting
- Validation: Lint rule to catch date formatting

### Rule 8: TypeScript Strict Mode
- Always use strict TypeScript
- No `any` types (use `unknown` if needed)
- Proper type definitions for all functions
- Use type guards for runtime checks

---

## Architecture Rules

### Rule 9: Feature-Based Structure
- Organize code by feature, not by type
- Each feature is self-contained
- Shared utilities in `utils/`
- Shared components in `components/common/`

**Structure:**
```
src/
├── features/
│   ├── auth/
│   │   ├── components/
│   │   ├── screens/
│   │   ├── hooks/
│   │   ├── store/
│   │   └── types.ts
│   ├── chat/
│   └── preview/
├── components/
│   └── common/    # Truly shared components
├── utils/
└── types/
```

### Rule 10: Design System Enforcement
- All styling uses design tokens
- No magic numbers (spacing, colors, etc.)
- Glassmorphism components for UI elements
- Theme switching must work everywhere

### Rule 11: Module System
- All capabilities are modules
- Modules are self-contained
- Modules can have dependencies
- Module conflicts must be resolved

---

## AI Agent Rules

### Rule 12: Mini-Steps in Agent Actions
- Agent breaks down requests into smallest possible steps
- Each step is one logical change
- Agent tests/validates after each step
- Agent doesn't proceed if step fails

### Rule 13: Autofix Limits
- Max 6 iterations per error type
- If same error repeats 2-3 times: switch strategy
- If still stuck: present user with 2-3 options
- Always rollback if change makes things worse

### Rule 14: Never Give Up Silently
- Agent always provides feedback
- If stuck, offer alternatives
- Never fail without explanation
- Always suggest next steps

### Rule 15: Code Quality Gates
- Agent runs lint before committing changes
- Agent runs tests before proceeding
- Agent checks for hardcoded text/dates
- Agent validates design system usage

---

## Security Rules

### Rule 16: Secrets Never in Code
- All secrets in vault/environment variables
- Never commit secrets to repo
- Never log secrets
- Use allowlist for commands

### Rule 17: Sandbox Isolation
- Each project runs in isolated environment
- No cross-tenant access
- Resource limits per project
- Input validation on all user data

### Rule 18: Destructive Actions Require Confirmation
- Drop table → confirmation required
- Delete project → confirmation required
- Change critical auth → confirmation required
- Delete storage bucket → confirmation required

---

## Documentation Rules

### Rule 19: Hidden Documentation
- Extensive documentation in `.internal/` folder
- README files are concise and professional
- Technical deep-dives in `.internal/docs/`
- User-facing docs in separate location

### Rule 20: Code Documentation
- JSDoc for public APIs
- Inline comments for complex logic
- README in each feature folder (brief)
- Architecture decisions in `.internal/docs/`

---

## Git & Version Control Rules

### Rule 21: Clean Git History
- One logical change per commit
- Meaningful commit messages
- No "WIP" or "fix" commits
- Squash commits in PR if needed

### Rule 22: Branch Strategy
- `main`: Production-ready code
- `develop`: Integration branch
- `feature/*`: New features
- `fix/*`: Bug fixes

### Rule 23: PR Requirements
- All tests pass
- Lint/format checks pass
- Code review required
- Preview must work

---

## Testing Rules

### Rule 24: Test Coverage
- Critical paths: 80%+ coverage
- Utilities: 90%+ coverage
- Components: Test user interactions
- Modules: Integration tests

### Rule 25: Test After Each Step
- Run tests before committing
- Fix failing tests immediately
- Don't accumulate test failures

---

## Performance Rules

### Rule 26: Bundle Size
- Monitor bundle size
- Use code splitting
- Lazy load heavy components
- Optimize images

### Rule 27: Preview Performance
- Preview should load in < 2s
- Use debouncing for updates
- Cache when possible
- Optimize re-renders

---

## Error Handling Rules

### Rule 28: Graceful Degradation
- Never crash the app
- Show user-friendly error messages
- Log errors to Sentry
- Provide recovery options

### Rule 29: Error Boundaries
- Wrap screens in error boundaries
- Catch and display errors gracefully
- Allow user to continue working
- Report errors for fixing

---

## Internationalization Rules

### Rule 30: i18n Key Structure
- Format: `feature.section.key`
- Example: `auth.login.title`
- All keys must be namespaced
- No generic keys like `button.ok`

### Rule 31: Language Support
- Auto-detect device language
- Fallback chain: `nb → en → key`
- In-app language picker
- All features support i18n

---

## Date/Time Rules

### Rule 32: UTC Storage
- All dates stored as UTC ISO-8601
- Convert to local timezone for display
- Use central Date util for all operations
- Never assume timezone

### Rule 33: Locale-Aware Formatting
- Format dates according to device locale
- Support all locales
- Relative time formatting (e.g., "2 hours ago")
- Use date-fns for formatting

---

## Module Development Rules

### Rule 34: Module Template
- Each module follows template structure
- Module includes: components, screens, hooks, store, types
- Module has i18n keys
- Module has tests

### Rule 35: Module Dependencies
- Declare dependencies explicitly
- Resolve conflicts before installation
- Document dependencies
- Test with dependencies

---

## Build & Preview Rules

### Rule 36: Build Validation
- All builds must pass lint
- All builds must pass tests
- Preview must work after build
- Build artifacts must be valid

### Rule 37: Preview Updates
- Preview updates automatically on changes
- Debounce rapid updates
- Show loading state during updates
- Handle preview errors gracefully

---

## Publishing Rules

### Rule 38: Publishing Checklist
- All tests pass
- No critical errors
- Store listing complete
- Icons/screenshots generated
- Privacy policy included

### Rule 39: Version Management
- Semantic versioning
- Increment version for each release
- Changelog for each release
- Tag releases in Git

---

## Cost Management Rules

### Rule 40: AI Usage Optimization
- Use GPT-3.5 for simple tasks
- Use GPT-4 for complex tasks
- Cache responses when possible
- Set token limits
- Monitor usage

### Rule 41: Build Cost Management
- Use incremental builds when possible
- Cache build artifacts
- Limit build frequency
- Use preview builds for testing

---

## Code Review Checklist

Before merging any PR, verify:

- [ ] Follows mini-steps principle (one logical change)
- [ ] All tests pass
- [ ] Lint/format checks pass
- [ ] No hardcoded text (uses i18n)
- [ ] No hardcoded dates (uses Date util)
- [ ] Design system used (tokens, not magic numbers)
- [ ] TypeScript strict mode (no `any`)
- [ ] Error handling present
- [ ] Comments are natural (not AI-marked)
- [ ] Preview works
- [ ] No secrets in code
- [ ] Documentation updated if needed

---

## Violation Handling

If a rule is violated:

1. **Identify the violation** (automated when possible)
2. **Fix immediately** (don't accumulate violations)
3. **Update process** if rule is unclear
4. **Document exception** if violation is intentional

---

## Rule Updates

These rules are living guidelines. Update as we learn:

- Add rules when patterns emerge
- Remove rules that don't work
- Clarify rules that are ambiguous
- Document exceptions

---

## Remember

**The goal is stable, professional, maintainable code that users love.**

Every rule serves this goal. If a rule conflicts with the goal, question the rule.

